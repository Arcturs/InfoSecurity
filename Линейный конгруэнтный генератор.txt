Линейный конгруэнтный генератор (LCG) Лемера - это один из простых и популярных алгоритмов для генерации псевдослучайных чисел. Он использует линейную рекуррентную формулу для генерации последовательности чисел. Формула для вычисления следующего числа в последовательности выглядит так:

Ui+1 = (Ui * M + C) mod p

Где:

Ui - текущее значение в последовательности
Ui+1 - следующее значение в последовательности
M - множитель
C - приращение (константа)
p - модуль, обычно выбирается как простое число или степень двойки
В данной формуле, Ui умножается на множитель M, затем к результату добавляется константа C, и всё это берется по модулю p, чтобы получить следующее псевдослучайное число в последовательности.

LCG Лемера имеет некоторые преимущества, такие как простота реализации, но также есть ограничения и недостатки, связанные с периодичностью последовательности, отсутствием полностью случайного распределения чисел и зависимостью от выбора параметров M, C, p и начального значения U0.

Параметр ( b ) является уровнем значимости и используется для определения доверительного интервала. В данном случае ( b = 0.99 ) означает, что мы хотим построить доверительный интервал с уровнем значимости 99%.

Параметр ( d ) представляет собой допустимую ошибку, которую мы готовы допустить при оценке параметров нашей выборки. В данном случае ( d = 0.01 ) означает, что допустимая ошибка составляет 0.01.

Функция distplot из библиотеки Seaborn используется для визуализации одномерного распределения данных. Она строит гистограмму с оценкой плотности распределения на основе предоставленных данных

Путем выполнения расчета гистограммы двухмерных данных, сконструированных из массива псевдослучайных чисел, можно визуализировать распределение пар значений взаимосвязанных данных. Это позволяет анализировать связь между парой значений и делать выводы о структуре данных и их зависимостях.


----------------------------------------------------------------------------------------------------------------
Данная функция factor(num) выполняет факторизацию числа на простые множители. Вот пошаговое объяснение ее работы:

Принимает входное число num, которое необходимо факторизовать на простые множители.
Инициализирует пустой список result, который будет содержать простые множители входного числа.
Устанавливает начальное значение делителя d на 2.
Начинает цикл, проверяя условие d * d <= num, чтобы продолжать факторизацию только до квадратного корня числа num, так как если существует простой множитель больше квадратного корня числа, то он должен быть парным множителем с другим множителем, который меньше квадратного корня.
В цикле проверяет, делится ли число num на текущий делитель d без остатка (num % d == 0).
Если да, добавляет делитель d в список result и делит num на d для продолжения факторизации.
Если нет, увеличивает значение делителя d на 1 для проверки следующего числа.
При завершении цикла, если оставшееся число num больше 1, добавляет его в список result, так как оно тоже является простым множителем.
Возвращает список result, содержащий все простые множители входного числа num.
Таким образом, функция factor(num) факторизует заданное число num на простые множители и возвращает их в виде списка.

Функции blocking(num, size_num, size_block) и decrypt(C, d, n) используются в контексте дешифрования сообщения, зашифрованного алгоритмом RSA. Вот объяснение их работы:

Функция blocking(num, size_num, size_block):
blocking разбивает число num на блоки нужного размера.
size_num - размер входного числа num в байтах.
size_block - размер блока, на который мы будем разбивать число.
Сначала число num преобразуется в байтовую строку фиксированного размера 'big'.
Затем эта строка разбивается на блоки размера size_block.
Результатом функции является список целых чисел, каждое из которых представляет значение одного блока из числа num.
Функция decrypt(C, d, n):
decrypt выполняет дешифрование зашифрованного текста C с помощью секретного ключа d и модуля n.
Сначала вызывается функция blocking для разбиения зашифрованного текста на блоки.
Далее каждый блок шифротекста восстанавливается в исходное число с помощью операции возведения в степень d по модулю n (действие обратное операции шифрования).
Полученные числа объединяются в байтовый массив res.
В конце конвертируется и возвращается полученный байтовый массив в виде целого числа.
Мы можем использовать функцию decrypt для дешифрования шифротекста C и восстановления исходного сообщения с помощью секретного ключа d и модуля n.